<?php
/**
 * ||GEISSWEB| EU VAT Enhanced
 *
 * NOTICE OF LICENSE
 *
 * This source file is subject to the GEISSWEB End User License Agreement
 * that is available through the world-wide-web at this URL: https://www.geissweb.de/legal-information/eula
 *
 * DISCLAIMER
 *
 * Do not edit this file if you wish to update the extension in the future. If you wish to customize the extension
 * for your needs please refer to our support for more information.
 *
 * @copyright   Copyright (c) 2015 GEISS Weblösungen (https://www.geissweb.de)
 * @license     https://www.geissweb.de/legal-information/eula GEISSWEB End User License Agreement
 */

namespace Geissweb\Euvat\Controller\Vatnumber;

use Geissweb\Euvat\Helper\Configuration;
use Geissweb\Euvat\Helper\Functions;
use Geissweb\Euvat\Logger\Logger;
use Geissweb\Euvat\Model\Validation\Syntax;
use Geissweb\Euvat\Model\Validation\Vies;
use Geissweb\Euvat\Model\ValidationRepository;
use Magento\Framework\App\Action\Context;
use Magento\Framework\Controller\Result\Json as JsonResult;
use Magento\Framework\Controller\Result\Raw as RawResult;
use Magento\Framework\Controller\Result\Redirect as RedirectResult;
use Magento\Framework\Controller\ResultFactory;
use Magento\Framework\Data\Form\FormKey\Validator;
use SoapFault;

/**
 * Class Validation
 * Executes the validation and gives JSON back
 */
class Validation extends \Magento\Framework\App\Action\Action
{
    /**
     * @var Context
     */
    public $context;

    /**
     * @var Logger
     */
    public $logger;

    /**
     * @var Functions
     */
    public $helper;

    /**
     * Validator for Formkey
     * @var Validator
     */
    protected $_formKeyValidator;

    /**
     * @var Configuration
     */
    public $configHelper;

    /**
     * @var Vies
     */
    public $viesService;

    /**
     * @var ValidationRepository
     */
    public $validationRepository;
    /**
     * @var Syntax
     */
    private $syntaxValidator;

    /**
     * Constructor
     *
     * @param Context              $context
     * @param Validator            $formKeyValidator
     * @param Functions            $helper
     * @param Configuration        $configHelper
     * @param Vies                 $viesService
     * @param Syntax               $syntaxValidator
     * @param Logger               $logger
     * @param ValidationRepository $validationRepository
     */
    public function __construct(
        Context $context,
        Validator $formKeyValidator,
        Functions $helper,
        Configuration $configHelper,
        Vies $viesService,
        Syntax $syntaxValidator,
        Logger $logger,
        ValidationRepository $validationRepository
    ) {
        parent::__construct($context);
        $this->context = $context;
        $this->_formKeyValidator = $formKeyValidator;
        $this->configHelper = $configHelper;
        $this->viesService = $viesService;
        $this->logger = $logger;
        $this->validationRepository = $validationRepository;
        $this->helper = $helper;
        $this->syntaxValidator = $syntaxValidator;
    }

    /**
     * Execute VAT number validation
     * @return JsonResult|RawResult|RedirectResult
     */
    public function execute()
    {
        if ($this->getRequest()->getMethod() !== 'POST'
            || !$this->getRequest()->isXmlHttpRequest()
            || !$this->_formKeyValidator->validate($this->getRequest())
        ) {
            $this->logger->debug("Aborting Controller: Request()->getMethod(): " . $this->getRequest()->getMethod());
            $this->logger->debug("Request()->isXmlHttpRequest(): " . $this->getRequest()->isXmlHttpRequest());
            $this->logger->debug("FormKey result: " . $this->_formKeyValidator->validate($this->getRequest()));
            /** @var \Magento\Framework\Controller\Result\Raw $resultRaw */
            $resultRaw = $this->resultFactory->create(ResultFactory::TYPE_RAW);
            return $resultRaw->setHttpResponseCode(400);
        }

        $needToValidate = true;
        $response = $this->viesService->getResult();

        $vatNumber = $this->getRequest()->getPost('vat_number');
        $vatCc = substr($vatNumber, 0, 2);
        $vatNumberWithoutCc = str_replace($vatCc, '', $vatNumber);

        // TODO: Implement GB VAT number validation through HMRC
        if ($vatCc == 'GB') {
            $this->viesService->setParam('countryCode', $vatCc);
            $this->viesService->setParam('vatNumber', $vatNumberWithoutCc);
            $response = $this->viesService->getOfflineResult(); //offline result
            $response->setVatIsValid(false);
            $response->setWarning(true);
            $response->setRequestMessage(
                __('Currently we can not validate VAT numbers from the United Kingdom.')
            );
            $response->setIsGB(true);
            return $this->resultFactory->create(ResultFactory::TYPE_JSON)->setData($response);
        }

        $existingValidation = $this->validationRepository->getByVatId($vatNumber);
        if ($existingValidation instanceof \Geissweb\Euvat\Api\Data\ValidationInterface) {
            //Estimate if we can reuse the existing validation
            $needToValidate = $this->helper->getNeedToValidate($vatNumber);
            //If we can reuse the existing validation
            if (!$needToValidate) {
                $isValid = (bool)$existingValidation->getVatIsValid();
                $isRequestSuccess = (bool)$existingValidation->getVatRequestSuccess();
                $existingValidation->setVatIsValid($isValid);
                $existingValidation->setVatRequestSuccess($isRequestSuccess);
                if ($isValid && $isRequestSuccess) {
                    $existingValidation->setRequestMessage(__('The VAT number is valid.'));
                } elseif (!$isValid && $isRequestSuccess) {
                    $existingValidation->setRequestMessage(__('The VAT number is invalid.'));
                }
                $response = $existingValidation; //db result
            }
        }

        if ($needToValidate) {
            try {
                //throw new \SoapFault('1', 'MS_UNAVAILABLE');
                $this->viesService->setParam('countryCode', $vatCc);
                $this->viesService->setParam('vatNumber', $vatNumberWithoutCc);
                $this->viesService->validate();
                $response = $this->viesService->getResult(); //regular result
                $this->_eventManager->dispatch('vat_validation_after', [
                    'validation_result' => $response
                ]);
            } catch (SoapFault $e) {
                $this->logger->critical($e);

                if ($this->configHelper->isOfflineValidationEnabled()
                    && $this->configHelper->isOfflineValidationCountry($vatCc)
                    && $this->syntaxValidator->isValid($vatNumberWithoutCc, $vatCc)
                ) {
                    $this->viesService->setParam('countryCode', $vatCc);
                    $this->viesService->setParam('vatNumber', $vatNumberWithoutCc);
                    $response = $this->viesService->getOfflineResult(); //offline result
                    $toSaveValidation = clone $response;
                    $toSaveValidation->setRequestMessage($e->getMessage());
                    $this->_eventManager->dispatch('vat_validation_after', [
                        'validation_result' => $toSaveValidation
                    ]);
                } else {
                    $response = $this->viesService->getResult(); //empty/new result
                    if ($response->getVatRequestId() === 'INIT') {
                        $response->setWarning(true);
                        $response->setRequestMessage(
                            __('VAT Number validation interface unavailable (' . $e->faultstring . ').')
                        );
                    }
                    switch ($e->faultstring) {
                        case 'INVALID_REQUESTER_INFO':
                        case 'Empty Requester VAT number':
                            $response->setRequestMessage(
                                __('Invalid requester information. Please check your merchant VAT number.')
                            );
                            $response->setError(true);
                            $response->setWarning(false);
                            break;
                        case 'MS_UNAVAILABLE':
                            $response->setRequestMessage(
                                __('Currently it is not possible to validate VAT numbers from this country.')
                            );
                            $response->setWarning(true);
                            break;
                        case 'TIMEOUT':
                            $response->setRequestMessage(
                                __('The connection to the validation interface timed out. Please try again.')
                            );
                            $response->setWarning(true);
                            break;
                        case 'INVALID_INPUT':
                        case 'Invalid_input':
                            $response->setRequestMessage(__('The VAT number is invalid.'));
                            $response->setError(true);
                            $response->setWarning(false);
                            break;
                        case 'GLOBAL_MAX_CONCURRENT_REQ':
                        case 'GLOBAL_MAX_CONCURRENT_REQ_TIME':
                        case 'MS_MAX_CONCURRENT_REQ':
                        case 'MS_MAX_CONCURRENT_REQ_TIME':
                        case 'SERVICE_UNAVAILABLE':
                            $response->setRequestMessage(__('The VAT number validation service is busy.'));
                            $response->setWarning(true);
                            break;
                        default:
                            $response->setRequestMessage($e->faultstring);
                            $response->setError(true);
                            $response->setWarning(false);
                            break;
                    }
                }
            }
        }

        return $this->resultFactory->create(ResultFactory::TYPE_JSON)->setData($response);
    }
}
